#ifndef __tcp_h_
#define __tcp_h_

#include <xccompat.h>

#include "xtcp.h"

#ifndef NULL
#define NULL 0
#endif

#define MAX_XTAG_TCP_CONNECTIONS 2
#define ETHER_XTAG_PORT 1337        // The network port to use for xtag traffic

/** \brief Initialise the XTAG state
 *
 * Adds a tcp listener to the EtherXTAG port (1337)
 */
void xtag_init(chanend tcp_svr);

/** \brief Initialise the connection buffer
 *
 * Sets all the connections in the buffer to inactive, so they can be used by
 * incoming connections as they are established.
 */
void xtag_connection_buffer_init();

/** \breif Sends a webpage back down the tcp connection
 *
 * Sends a webpage generated by web_service back down the tcp connection.
 */
void xtag_tcp_send(chanend tcp_svr, xtcp_connection_t &conn);

/** \brief If there's room, adds an incoming connection to the connections buffer
 *
 * This will set-up state in the 1st available slot in the connections buffer to
 * represent this connection.
 */
void xtag_accept_connection(chanend c_xtcp, xtcp_connection_t &conn);

/** \brief Removes a connection from the connections buffer
 *
 * This sets a given connection to inactive, so it may be claimed in
 * `accept_connection`
 */
void xtag_free_connection(xtcp_connection_t &conn);

/** \brief Handles a TCP event
 *
 * Switches through various TCP event scenarios, and handles them apropriately.
 */
void xtag_tcp_event(chanend c_xtcp, xtcp_connection_t &conn, chanend rst_a, chanend ip_out);

/** \brief Receives XTAG data
 *
 * Takes an XTAG packet, calls the XTAG library function to handle it, and sends
 * a response
 */
void xtag_recv_data(chanend c_xtcp, xtcp_connection_t &conn, chanend rst_a);

/** \brief This is called when the interface has been initialsed with an IP
 *
 * Currently only prints the IP the device has been configured with.
 */
void xtag_if_up(chanend c_xtcp);


#endif
